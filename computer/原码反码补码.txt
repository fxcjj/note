
一、机器数和真值
二、原码、反码、补码的基本概念和计算方法
三、为什么要使用原码、反码、补码
四、原码、反码、补码再深入
五、总结



一、机器数和真值
在学习原码、反码和补码之前，先了解下机器数和真值的概念

1、机器数
一个数在计算机中的二进制表示形式，叫做这个数的机器数。
机器数是带符号的，在计算机用一个数的最高位存放符号, 正数为0, 负数为1。
比如：
十进制中的数+3 ，计算机字长为8位，转换成二进制就是00000011。如果是-3，就是 10000011 。
那么，这里的 00000011 和 10000011 就是机器数。
这里的机器数不正确，应该是转换为补码形式，才是机器数！


2、真值
因为第一位是符号位，所以机器数的形式值就不等于真正的数值。例如上面的有符号数 10000011，其最高位1代表负，
其真正数值是 -3 而不是形式值131（10000011转换成十进制等于131）。所以，为区别起见，将带符号位的机器数对应的真正数值称为机器数的真值。

例：0000 0001的真值 = +000 0001 = +1，1000 0001的真值 = –000 0001 = –1


二、原码、反码、补码的基本概念和计算方法
对于一个数，计算机要使用一定的编码方式进行存储，原码、反码、补码是机器存储一个具体数字的编码方式。

1、原码
原码就是符号位加上真值的绝对值，即用第一位表示符号，其余位表示值。
比如：机器字长为8位，十进制的+1、-1对应的原码

[+1] = 0000 0001(原)
[-1] = 1000 0001(原)

第一位是符号位。
因为第一位是符号位，所以8位二进制的取值范围是：
[1111 1111, 0111 1111]

转换为十进制为
[-127, 127]

原码是人脑最容易理解和计算的表示方式。

2、反码
反码的表示方法是：
正数的反码是其本身。
负数的反码是在其原码的基础上，符号位不变，其余各位取反。
如：
[+3] = 0000 0011(原) = 0000 0011(反)
[-3] = 1000 0011(原) = 1111 1100(反)

可见如果一个反码表示的是负数，人脑无法直观的看出它的数据（不告诉你是原/反）。
通常要将其转换为原码再计算。

3、补码
补码的表示方法是：
正数的补码是其本身。
负数的补码是在其原码的基础上，符号位不变，其余各位取反，最后+1。（即在反码的基础上+1）
[+1] = 0000 0001(原) = 0000 0001(反) = 0000 0001(补)
[-1] = 1000 0001(原) = 1111 1110(反) = 1111 1111(补)

对于负数，补码的表示方式同样也是人类无法直观看出其数值的。
通常要将其转换为原码再计算。


三、为什么要使用原码、反码、补码
计算机可以有三种编码方式表示一个数。
对于正数，三种编码方式的结果是相同的：
	[+1] = 0000 0001(原) = 0000 0001(反) = 0000 0001(补)
但是对于负数：
	[-1] = 1000 0001(原) = 1111 1110(反) = 1111 1111(补)

可见对于一个负数，原码、反码、补码是完全不同的。
既然原码被人类直接识别并用于计算表示方式，为何还会有反码和补码呢？
对于人类，可以知道第一位是符号位，在计算的时候我们会根据符号位，选择对真值区或的加减。
但是对于计算机，加减乘除是最基础的运算，要设计的尽量简单。
计算机辨别“符号位”会使基础电路设计变得十分复杂。
于是人类想出了将符号位也参与运算的方法。

as we know, 根据运算法则减去一个正数等于加上这个数的负数，即：1-1 = 1+(-1) = 0，
所以机器可以只有加法而没有减法，这样计算机运算的设计就更简单了。

so, human start to research, 将符号位参与运算，并且只保留加法的方法。

首先来看原码：

计算十进制的表达式：1-1=0
1 - 1 
= 1 + (-1) 
= [0000 0001](原) + [1000 0001](原) 
= [1000 0010](原) 
= -2

如果用原码表示，让符号位也参与计算，显然对于减法来说，结果是不正确的。这也就是为何计算机内部不使用原码表示一个数。


为了解决原码做减法的问题，出现了反码：
计算十进制的表达式：1-1=0
1 - 1 
= 1 + (-1) 
= [0000 0001](原) + [1000 0001](原) 
= [0000 0001](反) + [1111 1110](反) 
= [1111 1111](反) 
= [1000 0000](原) 
= -0 //要将上面的转换为原码再计算

发现用反码计算减法，结果的真值 部分是正确的，多出了一个符号位。
而唯一的问题其实就出现在“0”这个特殊的值上，虽然人类理解+0和-0是一样的，但是0带符号是没有任何意义的。
而且会有[0000 0000](原)和[1000 0000](原)两个编码表示0.

于是补码的出现，解决了0的符号以及两个编码的问题：

1-1 
= 1 + (-1)
= [0000 0001](原) + [1000 0001](原) 
= [0000 0001](补) + [1111 1111](补)
= [0000 0000](补)
= [0000 0000](原) //补码转原码，根据上面的值的符号位可知，是一个正数，所以转换为原码时还是自身
= 0

15-8
= [0000 1111](原) + [1000 1000](原)
= [0000 1111](补) + [1111 10001](补)
= [0000 0111](补)
= 7

这样0用[0000 0000](补)表示，而以前出现问题的-0则不存在了。
而且可以用[1000 0000](补)表示-128.

(-1) + (-127)
= [1000 0001](原) + [1111 1111](原)
= [1111 1111](补) + [1000 0001](补)
= [1000 0000](补) //上面的[1000 0000](原)表示-0

-1-127的结果应该是-128，在用补码运算的结果中，[1000 0000](补)就是-128.
但是注意因为实际上是使用以前的-0的补码来表示-128，所以-128并没有原码和反码表示。
（对-128的补码表示[1000 0000]补算出来的原码是[0000 0000](原)，这是不正确的）。
使用补码，不仅仅修改了0的符号以及存在两个编码的问题，而且还能够多表示一个最低数。
这就是为什么8位二进制，使用原码或反码表示的范围是[-127, +127]（即[1111 1111, 0111 1111]），而使用补码表示的范围为[-128, 127]。
因为机器使用补码，所以对于编程中常用到的32位int类型，可以表示范围是[-2(31次方), 2(31)-1]因为第一位表示的是符号位。
而使用补码表示时又可以多保存一个最小值。


四、原码、反码、补码再深入
计算机巧妙地把符号位参与运算，并且将减法变成了加法，背后蕴含了怎样的数学原理呢？

将钟表想象成是一个1位的12进制数，如果当前时间是6点，我希望将时间设置成4点，
需要怎么做呢？我们可以：
1. 往加拨2个小时：6-2=4
2. 往前拨10个小时：(6+10) mod 12 = 4
3. 往前拨22个小时：(6+22) mod 12 = 4
2,3方法中的mod是指取模操作，16 mod 12 = 4,即用16除以12后的余数是4.

所以钟表往回拨（减法）的结果可以用往前拨（加法）替代！

现在的焦点就落在了如何用一个正数，来替代一个负数。
上面的例子我们能感觉出来一些端倪，发现一些规律。
但是数学是严谨的，不能靠感觉。

首先介绍一个数学中相关的概念：同余


同余的概念
两个整数a, b，若它们除以整数m所得的余数相等，则称a, b对于模m同余。
记作 a ≡ b (mod m)
读作a与b关于模m同余。

举例说明：
	4 mod 12 = 4
	16 mod 12 = 4
	28 mod 12 = 4
所以4, 16, 28关于模12同余。

负数取模
正数进行mod运算是很简单的，但是负数呢？
下面是关于mod运算的数学定义：
	x mod y = x - y[x/y], for <> y 
注意：上面的[x/y]是取下界值。

上面公式的意思是
	x mod y等于x减去y乘以x与y的商的下界
	
such as: -3 mod 2

-3 mod 2
= -3 - 2[-3/2]
= -3 - 2[-1.5]
= -3 - 2[-2]
= -3 + 4
= 1

所以

(-2) mod 12 = 12 - 2 = 10
(-4) mod 12 = 12 - 4 = 8
(-5) mod 12 = 12 - 5 = 7

开始证明
再回到时钟的问题上
	回拨2小时 = 前拨10小时
	回拨4小时 = 前拨8小时
	回拨5小时 = 前拨7小时
注意：这里发现的规律！

结合上面学到的同余的概念。实际上：
(-2) mod 12 = 12 - 2 = 10
10 mod 12 = 10

-2与10是同余的

(-4) mod 12 = 8
8 mod 12 = 8

-4与8是同余的。

距离成功越来越近了，要实现用正数替代负数，只需要运用同余数的两个定理：
反身性：
a ≡ a (mod m)

这个定理是很显而易见的。

线性运算定理：

如果a ≡ b(mod m), c ≡ d(mod m)那么：
(1)a±c ≡ b±d(mod m)
(2)a*c ≡ b*d(mod m)

定理证明：http://baike.baidu.com/view/79282.htm

所以：
7 ≡ 7(mod 12)
(-2) ≡ 10(mod 12)
7-2 ≡ 7 + 10(mod 12)
现在我们为一个负数, 找到了它的正数同余数. 但是并不是7-2 = 7+10, 而是 7 -2 ≡ 7 + 10 (mod 12) , 即计算结果的余数相等.










References
https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html
http://blog.csdn.net/u011080472/article/details/51280919



