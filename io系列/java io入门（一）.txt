
一、流及字节
流，一种抽象的数据的总称，它的本质是能够进行传输。
	a) 按照“流”的数据流向，可分为：输入流和输出流。
	b) 按照“流”中处理数据的单位，可分为：字节流和字符流。
在java中，字节是占1个Byte，即8位；而字符是占2个Byte，即16位。而且，需要注意的是，java的字节是有符号类型，而字符是无符号类型！

二、java io框架
1、以字节为单位的输入流的框架图
InputStream
	|--ByteArrayInputStream
	|--PipedInputStream
	|--FilterInputStream
		|--BufferedInputStream
		|--DataInputStream
	|--FileInputStream
		|-File
		|-FileDescriptor
	|--ObjectInputStream
01) InputStream 是以字节为单位的输入流的超类。InputStream提供了read()接口从输入流中读取字节数据。
02) ByteArrayInputStream 是字节数组输入流。它包含一个内部缓冲区，该缓冲区包含从流中读取的字节；通俗点说，它的内部缓冲区就是一个字节数组，
	而ByteArrayInputStream本质就是通过字节数组来实现的。
03) PipedInputStream 是管道输入流，它和PipedOutputStream一起使用，能实现多线程间的管道通信。
04) FilterInputStream 是过滤输入流。它是DataInputStream和BufferedInputStream的超类。
05) DataInputStream 是数据输入流。它是用来装饰其它输入流，它“允许应用程序以与机器无关方式从底层输入流中读取基本 Java 数据类型”。
06) BufferedInputStream 是缓冲输入流。它的作用是为另一个输入流添加缓冲功能。
07) File 是“文件”和“目录路径名”的抽象表示形式。关于File，注意两点：
	a), File不仅仅只是表示文件，它也可以表示目录！
	b), File虽然在io保重定义，但是它的超类是Object，而不是InputStream。
08) FileDescriptor 是“文件描述符”。它可以被用来表示开放文件、开放套接字等。
09) FileInputStream 是文件输入流。它通常用于对文件进行读取操作。
10) ObjectInputStream 是对象输入流。它和ObjectOutputStream一起，用来提供对“基本数据或对象”的持久存储。

2、以字节为单位的输出流的框架图
OutputStream
	|--ByteArrayOutputStream
	|--PipedOutputStream
	|--FilterOutputStream
		|--BufferedOutputStream
		|--DataOutputStream
		|--PrintStream
	|--FileOutputStream
		|--File
		|--FileDescriptor
	|--ObjectOutputStream
01) OutputStream 是以字节为单位的输出流的超类。OutputStream提供了write()接口从输出流中读取字节数据。
02) ByteArrayOutputStream 是字节数组输出流。写入ByteArrayOutputStream的数据被写入一个 byte 数组。
	缓冲区会随着数据的不断写入而自动增长。可使用 toByteArray() 和 toString() 获取数据。
03) PipedOutputStream 是管道输出流，它和PipedInputStream一起使用，能实现多线程间的管道通信。
04) FilterOutputStream 是过滤输出流。它是DataOutputStream，BufferedOutputStream和PrintStream的超类。
05) DataOutputStream 是数据输出流。它是用来装饰其它输出流，它“允许应用程序以与机器无关方式向底层写入基本 Java 数据类型”。
06) BufferedOutputStream 是缓冲输出流。它的作用是为另一个输出流添加缓冲功能。
07) PrintStream 是打印输出流。它是用来装饰其它输出流，能为其他输出流添加了功能，使它们能够方便地打印各种数据值表示形式。
08) FileOutputStream 是文件输出流。它通常用于向文件进行写入操作。
09) ObjectOutputStream 是对象输出流。它和ObjectInputStream一起，用来提供对“基本数据或对象”的持久存储。

3、以字符为单位的输入流的框架图
Reader
	|--CharArrayReader
	|--PipedReader
	|--FilterReader
	|--BufferedReader
	|--InputStreamReader
		|--FileReader
		|--File
01) Reader 是以字符为单位的输入流的超类。它提供了read()接口来取字符数据。
02) CharArrayReader 是字符数组输入流。它用于读取字符数组，它继承于Reader。操作的数据是以字符为单位！
03) PipedReader 是字符类型的管道输入流。它和PipedWriter一起是可以通过管道进行线程间的通讯。
	在使用管道通信时，必须将PipedWriter和PipedReader配套使用。
04) FilterReader 是字符类型的过滤输入流。
05) BufferedReader 是字符缓冲输入流。它的作用是为另一个输入流添加缓冲功能。
06) InputStreamReader 是字节转字符的输入流。它是字节流通向字符流的桥梁：它使用指定的 charset 读取字节并将其解码为字符。
07) FileReader 是字符类型的文件输入流。它通常用于对文件进行读取操作。

4、以字符为单位的输出流的框架图
Writer
	|--CharArrayWriter
	|--PipedWriter
	|--FilterWriter
	|--BufferedWriter
	|--OutputStreamWriter
		|--FileWriter
		|--File
	|--PrintWriter
01) Writer 是以字符为单位的输出流的超类。它提供了write()接口往其中写入数据。
02) CharArrayWriter 是字符数组输出流。它用于读取字符数组，它继承于Writer。操作的数据是以字符为单位！
03) PipedWriter 是字符类型的管道输出流。它和PipedReader一起是可以通过管道进行线程间的通讯。
	在使用管道通信时，必须将PipedWriter和PipedWriter配套使用。
04) FilterWriter 是字符类型的过滤输出流。
05) BufferedWriter 是字符缓冲输出流。它的作用是为另一个输出流添加缓冲功能。
06) OutputStreamWriter 是字节转字符的输出流。它是字节流通向字符流的桥梁：它使用指定的 charset 将字节转换为字符并写入。
07) FileWriter 是字符类型的文件输出流。它通常用于对文件进行读取操作。
08) PrintWriter 是字符类型的打印输出流。它是用来装饰其它输出流，能为其他输出流添加了功能，使它们能够方便地打印各种数据值表示形式。

5、字节转换为字符流
	File---->FileInputStream---->InputStreamReader---->FileReader
	a, InputStreamReader将字节流转换为字符。
		通过其构造方法传入InputStream参数
	b, OutputStreamWriter将字节流转换为字符流。
		通过其构造方法传入OutputStream参数

6、例子
public static void main(String[] args) throws IOException {
	StringBuilder sb = new StringBuilder();
	//BufferedInputStream
	BufferedInputStream bis = new BufferedInputStream(new FileInputStream(new File("d:/a.txt")));
	byte[] buf = new byte[1024];
	int tmp = 0;
	while((tmp = bis.read(buf)) != -1) {
		sb.append(new String(buf, 0, tmp));
	}
	System.out.println("文件的内容："+sb.toString());
	
	//InputStreamReader
	BufferedReader bufread;
	String read;
	bufread = new BufferedReader(new InputStreamReader(new BufferedInputStream(new FileInputStream(new File("d:/a.txt")))));
	while ((read = bufread.readLine()) != null) {
		System.out.println(read);
	}
	bufread.close();
}



