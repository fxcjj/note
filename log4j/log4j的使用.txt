

一、简介
Log4j是Apache开源的日志记录系统


二、第一个程序
首先将log4j-1.2.7.jar拷贝到你的类路径下，然后创建一个类。
代码如下：
LogTest.java
package cn.vic;
import org.apache.log4j.BasicConfigurator;
import org.apache.log4j.Logger;
import org.apache.log4j.Priority;
import org.apache.log4j.PropertyConfigurator;
public abstract class LogTest {
/**
* 得到Logger对象
* 通常以类的Class对象或全名作为参数
*/
static Logger logger = Logger.getLogger(LogTest.class.getName());
public static void main(String[] args) {
/**
* 初始化Log，如要把日志信息输出到哪儿
* 一般不用，多数情况下就通过log4j.properties或xml文件配置
*/
BasicConfigurator.configure(); 
logger.debug("debug"); 
logger.info("info"); 
logger.warn("warn"); 
logger.error("error"); 
logger.fatal("fatal"); 
}
}


//output:
0 [main] DEBUG cn.vic.LogTest  - debug
1 [main] INFO cn.vic.LogTest  - info
1 [main] WARN cn.vic.LogTest  - warn
1 [main] ERROR cn.vic.LogTest  - error
1 [main] FATAL cn.vic.LogTest  - fatal


日志信息的含义
0: 执行的毫秒数
[main]: 日志事件所在的线程
DEBUG: 日志级别
cn.vic.LogTest: LogTest所在的包和名称
debug: 日志信息


三、Logger及Level
Logger是从log4j1.2之后才有的，之前是Category作日志。
Logger是Category的子类。Logger类代码如下：
public class Logger {
// 创建和取回方法:  
public static Logger getRootLogger();
public static Logger getLogger(String name);
public static Logger getLogger(Class class1);   
// 打印方法:
public void debug(Object message);
public void info(Object message);
public void warn(Object message);
public void error(Object message);
public void fatal(Object message);

//打印出指定级别的日志信息
public void log(Level l, Object message);
}


Level是日志的级别有五种：DEBUG、INFO、WARN、ERROR、FATAL，从左到右级别依次增加！
DEBUG 为程序的调试信息
INFO 为一般要显示的信息，比如登录登出
WARN 为一般警告，比如session丢失
ERROR 为严重错误 主要是程序的错误
FATAL 要死的那种！


对于一个Logger,都会赋予一个级别，那么打印出来的日志信息，只能是>=这个级别。
例如：有一个级别为WARN的Logger对象，那么logger.warn(),logger.error(),logger.fatal()会打印出日志信息。
而logger.debug(),logger.info()不会打印出日志信息。


四、log4j.properties


Log4J配置文件的基本格式如下：


#配置根Logger
log4j.rootLogger = [level], appenderName1, appenderName2, ...


#配置日志信息输出目的地Appender
log4j.appender.appenderName = appender类的全路径
log4j.appender.appenderName.option1 = value1
...
log4j.appender.appenderName.optionN = valueN


#配置日志信息的格式（布局）
log4j.appender.appenderName.layout = layout类的全路径
log4j.appender.appenderName.layout.option1 = value1
...
log4j.appender.appenderName.layout.optionN = valueN


level取值:
DEBUG/INFO/WARN/ERROR/FATAL


Appender为日志输出目的地，Log4j提供的appender有以下几种：
org.apache.log4j.ConsoleAppender（控制台）
org.apache.log4j.FileAppender（文件）
org.apache.log4j.DailyRollingFileAppender（每天产生一个日志文件）
org.apache.log4j.RollingFileAppender（文件大小到达指定尺寸的时候产生一个新的文件）
将日志信息输出到一个文件，通过指定文件的的尺寸，
当文件大小到达指定尺寸的时候会自动把文件改名，如名为ex.log的文件会改名为ex.log.1，
同时产生一个新的ex.log文件。如果新的文件再次达到指定尺寸，又会自动把文件改名为ex.log.2，
同时产生一个ex.log文件。依此类推，直到ex.log. MaxBackupIndex，MaxBackupIndex的值可在配置文件中定义。
org.apache.log4j.WriterAppender（将日志信息以流格式发送到任意指定的地方）


Appender选项：
ConsoleAppender 选项
Threshold=DEBUG:指定日志消息的输出最低层次。
ImmediateFlush=true:默认值是true,意谓着所有的消息都会被立即输出。
Target=System.err：默认情况下是：System.out,指定输出控制台
FileAppender 选项
Threshold=DEBUF:指定日志消息的输出最低层次。
ImmediateFlush=true:默认值是true,意谓着所有的消息都会被立即输出。
File=mylog.txt:指定消息输出到mylog.txt文件。
Append=false:默认值是true,即将消息增加到指定文件中，false指将消息覆盖指定的文件内容。
RollingFileAppender 选项
Threshold=DEBUG:指定日志消息的输出最低层次。
ImmediateFlush=true:默认值是true,意谓着所有的消息都会被立即输出。
File=mylog.txt:指定消息输出到mylog.txt文件。
Append=false:默认值是true,即将消息增加到指定文件中，false指将消息覆盖指定的文件内容。
MaxFileSize=100KB: 后缀可以是KB, MB 或者是 GB. 在日志文件到达该大小时，将会自动滚动，即将原来的内容移到mylog.log.1文件。
MaxBackupIndex=2:指定可以产生的滚动文件的最大数。


Layout为日志输出格式，Log4j提供的layout有以下几种：
org.apache.log4j.HTMLLayout（以HTML表格形式布局）
org.apache.log4j.PatternLayout（可以灵活地指定布局模式）
org.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串）
org.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等等信息）


日志信息格式：
log4j.appender.A1.layout.ConversionPattern=%-4r %-5p %d{yyyy-MM-dd HH:mm:ssS} %c %m%n
符号所代表的含义：
-X号: X信息输出时左对齐；
%p: 输出日志信息优先级，即DEBUG，INFO，WARN，ERROR，FATAL,
%d: 输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，比如：%d{yyy MMM dd HH:mm:ss,SSS}，输出类似：2002年10月18日 22：10：28，921
%r: 输出自应用启动到输出该log信息耗费的毫秒数
%c: 输出日志信息所属的类目，通常就是所在类的全名
%t: 输出产生该日志事件的线程名
%l: 输出日志事件的发生位置，相当于%C.%M(%F:%L)的组合,包括类目名、发生的线程，以及在代码中的行数。举例：Testlog4.main (TestLog4.Java:10)
%x: 输出和当前线程相关联的NDC(嵌套诊断环境),尤其用到像java servlets这样的多客户多线程的应用中。
%%: 输出一个"%"字符
%F: 输出日志消息产生时所在的文件名称
%L: 输出代码中的行号
%m: 输出代码中指定的消息,产生的日志具体信息
%n: 输出一个回车换行符，Windows平台为"/r/n"，Unix平台为"/n"输出日志信息换行
可以在%与模式字符之间加上修饰符来控制其最小宽度、最大宽度、和文本的对齐方式。如：
1)%20c：指定输出category的名称，最小的宽度是20，如果category的名称小于20的话，默认的情况下右对齐。
2)%-20c:指定输出category的名称，最小的宽度是20，如果category的名称小于20的话，"-"号指定左对齐。
3)%.30c:指定输出category的名称，最大的宽度是30，如果category的名称大于30的话，就会将左边多出的字符截掉，但小于30的话也不会有空格。
4)%20.30c:如果category的名称小于20就补空格，并且右对齐，如果其名称长于30字符，就从左边较远输出的字符截掉。


四、记录器的层次
---------- log4j.properties配置文件开始 ------------
# rootLogger
log4j.rootLogger = INFO, stdout
log4j.appender.stdout = org.apache.log4j.ConsoleAppender
log4j.appender.stdout.layout = org.apache.log4j.PatternLayout
log4j.appender.stdout.layout.ConversionPattern = %-4r [%t] %-5p %c %x - %m%n

# 为package(cn.vic.log4j)定义Level及Appender
log4j.logger.cn.vic.log4j.TestLog4j = DEBUG, R

# 为package(cn.vic.log4j.son)定义Level及Appender
# 而Appender不存在，则向上找(cn.vic.log4j),找到则使用找到的Appender。
# 否则继续往上找，直到rootLogger(一定会存在)
log4j.logger.cn.vic.log4j.son = WARN

# 产出一个文件
log4j.appender.R = org.apache.log4j.RollingFileAppender
# 文件路径
log4j.appender.R.File = D://ex.log

# 文件大小
log4j.appender.R.MaxFileSize = 20KB
# 允许备份个数
log4j.appender.R.MaxBackupIndex = 1


# layout
log4j.appender.R.layout = org.apache.log4j.PatternLayout
log4j.appender.R.layout.ConversionPattern = %d{yyyy-MM-dd hh:mm:ss}:%p %t %c - %m%n
---------- log4j.properties配置文件结束 ------------


java代码
TestLog4j.java
package cn.vic.log4j;
import org.apache.log4j.Logger;
import org.apache.log4j.PropertyConfigurator;
import cn.vic.log4j.son.TestLog4jSon;
public class TestLog4j {
static final Logger logger = Logger.getLogger(TestLog4j.class.getName());
public static void main(String[] args) {
PropertyConfigurator.configure("D://log4j.properties");
logger.debug("TestLog4j debug message");
logger.info("TestLog4j info message");
logger.warn("TestLog4j warn message");
logger.error("TestLog4j error message");
logger.fatal("TestLog4j fatal message");
// 调用TestLog4jSon对象的log()方法
TestLog4jSon t1 = new TestLog4jSon();
t1.log();
}
}


TestLog4jSon.java
package cn.vic.log4j.son;
import org.apache.log4j.Logger;
public class TestLog4jSon {
static final Logger logger = Logger.getLogger(TestLog4jSon.class.getName());
public void log() {
logger.debug("TestLog4jSon debug message");
logger.info("TestLog4jSon info message");
logger.warn("TestLog4jSon warn message");
logger.error("TestLog4jSon error message");
logger.fatal("TestLog4jSon fatal message");
}
}


控制台打印：
0    [main] DEBUG cn.vic.log4j.TestLog4j  - TestLog4j debug message
0    [main] INFO  cn.vic.log4j.TestLog4j  - TestLog4j info message
0    [main] WARN  cn.vic.log4j.TestLog4j  - TestLog4j warn message
0    [main] ERROR cn.vic.log4j.TestLog4j  - TestLog4j error message
0    [main] FATAL cn.vic.log4j.TestLog4j  - TestLog4j fatal message
0    [main] WARN  cn.vic.log4j.son.TestLog4jSon  - TestLog4jSon warn message
0    [main] ERROR cn.vic.log4j.son.TestLog4jSon  - TestLog4jSon error message
0    [main] FATAL cn.vic.log4j.son.TestLog4jSon  - TestLog4jSon fatal message


文件输出：
2016-06-02 02:41:10:DEBUG main cn.vic.log4j.TestLog4j - TestLog4j debug message
2016-06-02 02:41:10:INFO main cn.vic.log4j.TestLog4j - TestLog4j info message
2016-06-02 02:41:10:WARN main cn.vic.log4j.TestLog4j - TestLog4j warn message
2016-06-02 02:41:10:ERROR main cn.vic.log4j.TestLog4j - TestLog4j error message
2016-06-02 02:41:10:FATAL main cn.vic.log4j.TestLog4j - TestLog4j fatal message


在配置文件中有
log4j.logger.cn.vic.log4j.TestLog4j = DEBUG, R
说明打印级别为DEBUG, 继承rootLogger，Appender有stdout和R


在配置文件中有
log4j.logger.cn.vic.log4j.son = WARN
说明打印级别为WARN, Appender不存在，往上找cn.vic.log4j不存在，
继续往上找cn.vic不存在，继续往上找cn不存在，则使用rootLogger的Appender。
所以控制台打印级别为WARN的日志信息。而文件中没有打印。


五、配置文件例子
创建数据库表，Appender为JDBC时使用
CREATE TABLE `log4j` (
  `log_id` int(11) NOT NULL AUTO_INCREMENT,
  `message` varchar(1024) DEFAULT NULL,
  `priority` varchar(10) DEFAULT NULL,
  `milliseconds` int(11) DEFAULT NULL,
  `category` varchar(256) DEFAULT NULL,
  `thread` varchar(100) DEFAULT NULL,
  `ndc` varchar(256) DEFAULT NULL,
  `create_date` timestamp NULL DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP,
  `location` varchar(256) DEFAULT NULL,
  `caller` varchar(100) DEFAULT NULL,
  `method` varchar(100) DEFAULT NULL,
  `filename` varchar(100) DEFAULT NULL,
  `line` int(11) DEFAULT NULL,
  PRIMARY KEY (`log_id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;


#1 定义了三个Appender
log4j.rootLogger = INFO, A1, A2, A3


#2 定义A1输出到控制器
log4j.appender.A1 = org.apache.log4j.ConsoleAppender
#3 定义A1的布局模式为PatternLayout
log4j.appender.A1.layout = org.apache.log4j.PatternLayout
#4 定义A1的输出格式
log4j.appender.A1.layout.ConversionPattern = %-4r [%t] %-5p %c - %m%n


#5 定义A2输出到文件
log4j.appender.A2 = org.apache.log4j.RollingFileAppender
#6 定义A2要输出到哪一个文件
log4j.appender.A2.File = D://ex.log
#7 定义A2的输出文件的最大长度
log4j.appender.A2.MaxFileSize = 5KB
#8 定义A2的备份文件数
log4j.appender.A2.MaxBackupIndex = 3
#9 定义A2的布局模式为PatternLayout
log4j.appender.A2.layout = org.apache.log4j.PatternLayout
#10 定义A2的输出格式
log4j.appender.A2.layout.ConversionPattern = %d{yyyy-MM-dd hh:mm:ss}:%p %t %c - %m%n

#11 定义A3输出到数据库
log4j.appender.A3 = org.apache.log4j.jdbc.JDBCAppender
log4j.appender.A3.BufferSize = 40
log4j.appender.A3.Driver = com.mysql.jdbc.Driver
log4j.appender.A3.URL = jdbc:MySQL://127.0.0.1:3306/latch
log4j.appender.A3.User = sa
log4j.appender.A3.Password = 
log4j.appender.A3.layout = org.apache.log4j.PatternLayout
log4j.appender.A3.layout.ConversionPattern = INSERT INTO log4j (message, priority, milliseconds, category, thread, create_date) 
VALUES('%m', '%p', '%r', '%c', '%t', '%d{yyyy-MM-dd HH:mm:ss}');


#5-#10处定义了RollingFileAppender及它特有的参数
#7 定义文件的大小
#8 定义文件的备份个数
具体作用为：
1) 当ex.log文件的大小超过5K时，就把文件改名为ex.log.1，同时生成一个新的ex.log文件
2) 当ex.log文件的大小再次超过5K，又把文件改名为ex.log.1。但由于此时ex.log.1已存在，
则先把ex.log.1更名为ex.log.2，再把ex.log文件改名为ex.log.1
3) 同理，当ex.log文件的大小再次超过5K，先把ex.log.2文件更名为ex.log.3，
把ex.log.1文件更名为ex.log.2，再把ex.log文件改名为ex.log.1
4) 当ex.log文件的大小再次超过5K，先把ex.log.2文件更名为ex.log.3，旧的ex.log.3文件将被覆盖；
把ex.log.1文件更名为ex.log.2，旧的ex.log.2文件被覆盖
最后把ex.log文件改名为ex.log.1并覆盖掉旧的ex.log.1文件。


六、总结
a, log4j.properties文件的基本配置
b, rootLogger为根记录器
c, Level有DEBUG,INFO,WARN,ERROR,FATAL
d, Appender为日志输出目的地(控制台，文件，数据库等)
e, 配置多个Appender
f, 日志信息的布局及格式
g, logger自下往上取机制

