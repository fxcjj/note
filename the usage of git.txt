
git的使用

1 安装Git
	安装完成后，在电脑某个目录右击，选择git bash here，出现的界面是linux界面，
	在这个界面里执行如下：
	
	//设置用户名和Email
	$ git config --global user.name "Your Name"
	$ git config --global user.email "email@example.com"
	
2 创建版本库	
	//创建git仓库
	$ mkdir learngit
	$ cd learngit
	$ git init
	Initialized empty Git repository in /Users/michael/learngit/.git/

3 查看库状态
	//查看仓库当前状态
	$ git status
	# On branch master
	# Changes not staged for commit:
	#   (use "git add <file>..." to update what will be committed)
	#   (use "git checkout -- <file>..." to discard changes in working directory)
	#
	#    modified:   readme.txt
	#
	no changes added to commit (use "git add" and/or "git commit -a")
	
	//查看修改了哪些内容
	$ git diff readme.txt 
	diff --git a/readme.txt b/readme.txt
	index 46d49bf..9247db6 100644
	--- a/readme.txt
	+++ b/readme.txt
	@@ -1,2 +1,2 @@
	-Git is a version control system.
	+Git is a distributed version control system.
	Git is free software.
	
	//提交修改和提交新文件是一样的两步，先add,再commit
	
4 版本回退
	//查看日志
	$ git log --pretty=oneline
	5c9169a7fd16a9bbbede81055b77f3e328d58325 update readme.txt
	90250ad58fd028f674a31c4fb509117e02695b61 add 3 files
	c2a45be2694230b78592d51d27fd7e83bac45cb4 wrote a readme file

	//head表示当前版本，head^表示上一个版本，head^^表示上上一个版本，head~100表示上100个版本
	//commit id表示版本号
	
	//回退版本
	$ git reset --hard HEAD^
	HEAD is now at ea34578 add distributed
	
	//我擦，回退错了肿么办，不怕，只要有commit id就可以回到未来
	$ git reset --hard 3628164
	HEAD is now at 3628164 append GPL
	
	//我擦，没有commit id肿么办，不怕，有后悔药！
	//reflog命令记录你的每一次命令
	$ git reflog
	5c9169a HEAD@{0}: reset: moving to head^
	3c8d5ad HEAD@{1}: reset: moving to 3c8d5adf096a4e
	5c9169a HEAD@{2}: reset: moving to head^
	3c8d5ad HEAD@{3}: commit: add wtf
	5c9169a HEAD@{4}: commit: update readme.txt
	90250ad HEAD@{5}: commit: add 3 files
	c2a45be HEAD@{6}: commit (initial): wrote a readme file
	
	//我胡汉三又回来了
	$ git reset --hard 3c8d5ad
	HEAD is now at 3c8d5ad add wtf
	
5 工作区和暂存区
//工作区和暂存区的图
http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013745374151782eb658c5a5ca454eaa451661275886c6000

工作区（Working Directory）
就是你在电脑里能看到的目录，比如我的learngit文件夹就是一个工作区

版本库（Repository）
工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。
Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。

分支和HEAD的概念我们以后再讲。

前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的：
第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区；
第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。
因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，git commit就是往master分支上提交更改。
你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。

6 管理修改
什么是修改？比如你新增了一行，这就是一个修改，删除了一行，也是一个修改，更改了某些字符，也是一个修改，删了一些又加了一些，也是一个修改，甚至创建一个新文件，也算一个修改。
step
1)修改readme.txt，在末尾添加一行
2)git add readme.txt
3)再次修改readme.txt
4)git commit -m "first edit"
5)git status //发现第二次修改没提交

git管理的是修改，当你用git add命令，只是把文件提交到stage区，使用git commit才会把stage区的文件提交到branch。
那第二次的修改没有add，所以还在工作区。	
此时，可以用
$ git diff HEAD -- readme.txt
查看工作区和版本库里面最新版本的区别

那怎么提交第二次修改呢？
先add，再commit。

每次修改，如果不add到暂存区，那就不会加入到commit中。

7 撤销修改
场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout -- file。
场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD file，就回到了场景1，第二步按场景1操作。
注：使用tortoisegit的Revert命令
当先后两次修改，都add到stage区，执行Revert操作两次修改都丢弃。
当第一次修改，add到stage区，第二次修改不add，执行Revert操作两次修改都丢弃。

8 删除文件
	$ rm a.txt
	执行上面删除命令，可以使用git checkout -- a.txt恢复
	
	$ git rm b.txt
	执行上面命令，可以使用git checkout -- a.txt无法恢复
	提示：
	error: pathspec 'b.txt' did not match any file(s) known to git.
	
	解决？
	$ git reset head c.txt
		Unstaged changes after reset:
		D       c.txt
	$ git checkout -- c.txt
	$ git status
		On branch master
		nothing to commit, working directory clean

9 远程仓库
	1)在github上新建远程库，记得要把pubkey加到github上
	2)关联一个远程库，在自己的clairvoyant库下面使用命令git remote add origin git@github.com:fxcjj/clairvoyant.git
	3)关联后，使用命令git push -u origin master 第一次推送master分支的所有内容.
		把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。
		由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，
		还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。
	4)此后，使用命令git push origin master推送即可。

10 从远程库克隆
	1)要克隆一个仓库，首先必须知道仓库的地址，然后使用git clone命令克隆。
	2)Git支持多种协议，包括https，但通过ssh支持的原生git协议速度最快。
	3)git clone git@github.com:fxcjj/clairvoyant.git

11 创建与合并分支
每次提交都是提交到一个时间线上，当前时间线为HEAD。
HEAD指向当前的branch，当切换branch时，HEAD会跟着指向新branch。

//创建dev分支，然后切换到dev分支
git checkout -b dev

//查看分支
git branch
* dev
  master

前面有*的表示当前分支

//在dev分支新建c.txt并提交
touch c.txt
git add c.txt
git commit -m "add c.txt"

//切换到master分支，查看c.txt
git checkout master
ls //此时c.txt文件并不存在master分支上

//将dev合并到master上
git merge dev //将dev分支合并到当前分支上
Updating d17efd8..fec145a
Fast-forward
 a.txt |    1 +
 1 file changed, 1 insertion(+)
//注意上面的Fast-forward信息，表示“快进模式”，
即直接把master指向dev的当前提交，所以合并速度非常快。

//删除dev分支
git branch -d dev

Conclusion
查看分支：git branch
创建分支：git branch <name>
切换分支：git checkout <name>
创建+切换分支：git checkout -b <name>
合并某分支到当前分支：git merge <name>
删除分支： git branch -d <name>



12 解决冲突
人生不如意之事十之八九。

//创建fe分支并切换到fe
git checkout -b fe

//修改a.txt文件
vi a.txt
git add a.txt
git commit -m "add sth"

//切换到master分支并修改a.txt
git checkout master //Your branch is ahead of 'origin/master' by 1 commit.
vi a.txt
git add a.txt
git commit -m "add sth"

//合并fe分支到当前分支
git merge fe
Auto-merging a.txt
CONFLICT (content): Merge conflict in a.txt
Automatic merge failed; fix conflicts and then commit the result.

//现在文件发生冲突了，必须手工解决才行。
//查看工作区
git status

//查看冲突文件
cat a.txt
<<<<<<< HEAD
abc & ddddddddd
=======
abc and dddd
what can i do for you?
>>>>>>> fe1

//修改完毕后
git add a.txt
git commit -m "fix conflict"

//用带参数的git log命令可以看到分支的合并情况
git log --graph --pretty=oneline --abbrev-commit
* 0b6bb88 add dd
*   d41a761 fix conflict
|\
| * 613bfae and ddd
* | 8e2b2f8 & ddd
* | d798348 & simple
|/
* 309cd83 add c.txt
* bc171b0 add b.txt
* 505d08c create a.txt

//删除分支fe
git branch -d fe

Conclusion
将某个分支合并到当前分支时，可能会有冲突，此时要处理冲突后，才能提交。
使用git log --graph可以看到分支合并图。


13 分支管理策略
//使用no-ff方式合并（之前是Fast-forward模式）
//新建分支fly
git checkout -b fly

//修改b.txt
vi b.txt
git add b.txt
git commit -m "xxx"

//切换到master分支，执行合并
git merge --no-ff -m "merge with no-ff" fly

#分支策略
master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活。
要在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，
再把dev分支合并到master分支上，在master分支发布1.0版本。

Conclusion
合并分支时，加上--no-ff参数表示使用普通模式合并，合并后的历史有分支，
能看出来曾经做过合并，而fast-forward合并看不出来曾经做过合并。


14 Bug分支
有如下场景
你在dev分支上正在开发，突然你收到了一个代号110的紧急bug，此时你需要保存当前dev分支现场。
先处理完bug，再回到dev分支上开发。

how to do?
//使用git stash命令将当前工作（fly分支）现场“储藏”起来，等以后恢复现场后继续工作。
git stash
Saved working directory and index state WIP on fly: fbd673d add line
HEAD is now at fbd673d add line
//此时工作区是干净的

//回到master分支
git checkout master
git checkout -b issue-110

//修得bug后，切换到master分支，并完成合并，最后删除issue-110分支。
git checkout master
git merge --no-ff -m "fix bug" issue-110

NOW，是时候回到fly分支干活了。
//切换到fly分支
git checkout fly

//工作现场存到哪儿了？用git stash list命令查看
git stash list
stash@{0}: WIP on fly: fbd673d add line

//工作现场还在，需要恢复下，两种方式
方式1
使用git stash apply，但是恢复后，stash内容并不删除，需要用git stash drop来删除。

方式2
使用git stash pop，恢复的同时把stash内容也删了。

git stash pop
On branch fly
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

        modified:   b.txt

no changes added to commit (use "git add" and/or "git commit -a")
Dropped refs/stash@{0} (d4b2fc2442cf58496a12087759beec461f8fce0f)

此时git stash list什么也没有了


可以多次stash，恢复的时候，先用git stash list查看，然后再恢复指定的stash，使用下面命令。
git stash apply stash@{0}

Conclusion
修复bug时，可以通过创建新的分支处理bug，而不影响当前dev分支。
当手头工作没有完成时，可以先使用git stash命令保存起来，修复完bug后，
再使用git stash pop恢复工作现场。

15 Feature分支
当添加一个新功能时，不希望在当前分支上折腾，可以新建一个feature分支，在此分支上开发，
合并，最后删除。

//新建一个feature分支
git checkout -b feature-vulcan

//4分钟后，开发完毕，切换到dev分支，准备合并
git checkout dev
此时，经费不足，计划中止，销毁分支
git branch -d feature-vulcan
error: The branch 'feature-vulcan' is not fully merged.
If you are sure you want to delete it, run 'git branch -D feature-vulcan'.

提示销毁失败，feature-vulcan分支还没有被合并，如果删除，将丢失修改，如果要强行删除，
需要使用命令git branch -D feature-vulcan.

//强行删除
git branch -D feature-vulcan

Conclusion
开发一个新feature时，最好新建一个分支。
如果要丢弃一个没有被合并过的分支，使用强行删除命令git branch -D feature-vulcan。


16 多人协作
当从远程库克隆时，git会自动把本地的master分支和远程的master分支对应起来，
并且，远程库的默认名称是origin

//查看远程库信息
git remote

//或者使用-v参数显示更详细的信息
git remote -v
origin  git@github.com:fxcjj/fuckgit.git (fetch)
origin  git@github.com:fxcjj/fuckgit.git (push)

上面显示了可以抓取和推送的origin地址。如果没有推送权限，就看不到push地址。

推送分支
就是把分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，
git就会把分支推送到远程库对应的远程分支上。
git push origin master

如果要推送其他分支，比如dev，就改成
git push origin dev

master分支是主分支，因此时刻与远程同步
dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步。

抓取分支
多人协作时，大家都会往master、dev推送各自的修改。

A君
//克隆远程库
git clone git@github.com:fxcjj/fuckgit.git

//创建本地dev分支
$ git checkout -b dev origin/dev
fatal: Cannot update paths and switch to branch 'dev' at the same time.
Did you intend to checkout 'origin/dev' which can not be resolved as commit?

上面报错是因为远程库上没有dev分支

$ git fetch
From github.com:fxcjj/fuckgit
 * [new branch]      dev        -> origin/dev

$ git checkout -b dev origin/dev
Branch dev set up to track remote branch dev from origin.
Switched to a new branch 'dev'

现在修改b.txt，然后提交，push到远程origin/dev分支
git push dev origin/dev

B君
//抓取远程
git fetch
remote: Counting objects: 3, done.
remote: Compressing objects: 100% (2/2), done.
Unpacking objects: 100% (3/3), done.
remote: Total 3 (delta 0), reused 3 (delta 0), pack-reused 0
From github.com:fxcjj/fuckgit
 * [new branch]      dev        -> origin/dev

//切换到dev分支
git checkout dev

此时也修改相同文件，并提交，push
git add b.txt
git commit -m "update b.txt"
$ git push origin dev
To git@github.com:fxcjj/fuckgit.git
 ! [rejected]        dev -> dev (fetch first)
error: failed to push some refs to 'git@github.com:fxcjj/fuckgit.git'
hint: Updates were rejected because the remote contains work that you do
hint: not have locally. This is usually caused by another repository pushing
hint: to the same ref. You may want to first integrate the remote changes
hint: (e.g., 'git pull ...') before pushing again.
hint: See the 'Note about fast-forwards' in 'git push --help' for details.

//出现错误，要git pull一下下
$ git pull
remote: Counting objects: 3, done.
remote: Compressing objects: 100% (2/2), done.
remote: Total 3 (delta 0), reused 3 (delta 0), pack-reused 0
Unpacking objects: 100% (3/3), done.
From github.com:fxcjj/fuckgit
   c97a7ff..4373914  dev        -> origin/dev
Auto-merging b.txt
CONFLICT (content): Merge conflict in b.txt
Automatic merge failed; fix conflicts and then commit the result.

处理冲突后，再提交push即可。

//如果git pull失败了
git pull
remote: Counting objects: 5, done.
remote: Compressing objects: 100% (2/2), done.
remote: Total 3 (delta 0), reused 3 (delta 0)
Unpacking objects: 100% (3/3), done.
From github.com:michaelliao/learngit
   fc38031..291bea8  dev        -> origin/dev
There is no tracking information for the current branch.
Please specify which branch you want to merge with.
See git-pull(1) for details

    git pull <remote> <branch>

If you wish to set tracking information for this branch you can do so with:

    git branch --set-upstream dev origin/<branch>

原因是没有指定本地dev分支与远程库origin/dev分支的链接，根据提示，设置dev和origin/dev的链接。
git branch --set-upstream dev origin/dev
Branch dev set up to track remote branch dev from origin

再pull即可

Conclusion
1 推送本地分支到远程库 git push origin <branch-name>
2 如果推送失败，说明本地分支过期，git pull
3 如果有冲突，处理冲突
4 没有冲突或者冲突解决后，再用git push origin <branch-name>推送。
5 如果git pull提示no tracking information，则说明本地分支和远程分支的链接没有创建。，
	使用命令git branch --set-upstream branch-name origin/branch-name	
6 查看远程库信息，使用git remote -v


17 标签管理


























