
一、机器数和真值
二、原码、反码、补码的基本概念和计算方法
三、为什么要使用原码、反码、补码
四、原码、反码、补码再深入
五、总结




一、机器数和真值
在学习原码、反码和补码之前，先了解下机器数和真值的概念

1、机器数
一个数在计算机中的二进制表示形式,  叫做这个数的机器数。机器数是带符号的，在计算机用一个数的最高位存放符号, 正数为0, 负数为1.
比如，十进制中的数 +3 ，计算机字长为8位，转换成二进制就是00000011。如果是 -3 ，就是 10000011 。
那么，这里的 00000011 和 10000011 就是机器数。

2、真值
因为第一位是符号位，所以机器数的形式值就不等于真正的数值。例如上面的有符号数 10000011，其最高位1代表负，其真正数值是 -3 而不是形式值131（10000011转换成十进制等于131）。所以，为区别起见，将带符号位的机器数对应的真正数值称为机器数的真值。

例：0000 0001的真值 = +000 0001 = +1，1000 0001的真值 = –000 0001 = –1


二、原码、反码、补码的基本概念和计算方法
对于一个数，计算机要使用一定的编码方式进行存储，原码、反码、补码是机器存储一个具体数字的编码方式。

1、原码
原码就是符号位加上真值的绝对值，即用第一位表示符号，其余位表示值。
比如：机器字长为8位，十进制的+1、-1对应的原码

[+1] = 0000 0001(原)
[-1] = 1000 0001(原)

第一位是符号位。
因为第一位是符号位，所以8位二进制的取值范围是：
[1111 1111, 0111 1111]

转换为十进制为
[-127, 127]

原码是人脑最容易理解和计算的表示方式。

2、反码
反码的表示方法是：
正数的反码是其本身。
负数的反码是在其原码的基础上，符号位不变，其余各位取反。
如：
[+3] = 0000 0011(原) = 0000 0011(反)
[-3] = 1000 0011(原) = 1111 1100(反)

可见如果一个反码表示的是负数，人脑无法直观的看出它的数据（不告诉你是原/反）。
通常要将其转换为原码再计算。

3、补码
补码的表示方法是：
正数的补码是其本身。
负数的补码是在其原码的基础上，符号位不变，其余各位取反，最后+1。（即在反码的基础上+1）
[+1] = 0000 0001(原) = 0000 0001(反) = 0000 0001(补)
[-1] = 1000 0001(原) = 1111 1110(反) = 1111 1111(补)

对于负数，补码的表示方式同样也是人类无法直观看出其数值的。
通常要将其转换为原码再计算。


三、为什么要使用原码、反码、补码
计算机可以有三种编码方式表示一个数。
对于正数，三种编码方式的结果是相同的：
	[+1] = 0000 0001(原) = 0000 0001(反) = 0000 0001(补)
但是对于负数：
	[-1] = 1000 0001(原) = 1111 1110(反) = 1111 1111(补)

可见对于负数，原码、反码、补码是完全不同的。
既然原码被人类直接识别并用于计算表示方式，为何还会有反码和补码呢？
对于人类，可以知道第一位是符号位，在计算的时候我们会根据符号位，选择对真值区或的加减。
但是对于计算机，加减乘除是最基础的运算，要设计的尽量简单。
计算机辨别“符号位”会使基础电路设计变得十分复杂。
于是人类想出了将符号位也参与运算的方法。

as we know, 根据运算法则减去一个正数等于加上这个数的负数，即：1-1 = 1+(-1) = 0，所以机器可以只有加法而没有减法，这样计算机运算的设计就更简单了。

so, human start to research, 将符号位参与运算，并且只保留加法的方法。

首先来看原码：

计算十进制的表达式：1-1=0
1 - 1 
= 1 + (-1) 
= [0000 0001](原) + [1000 0001](原) 
= [1000 0010](原) 
= -2

如果用原码表示，让符号位也参与计算，显然对于减法来说，结果是不正确的。这也就是为何计算机内部不使用原码表示一个数。


为了解决原码做减法的问题，出现了反码：
计算十进制的表达式：1-1=0
1 - 1 
= 1 + (-1) 
= [0000 0001](原) + [1000 0001](原) 
= [0000 0001](反) + [1111 1110](反) 
= 1111 1111(反) 
= -0

发现用反码计算减法，结果的真值 部分是正确的，多出了一个符号位。
而唯一的问题其实就出现在“0”这个特殊的值上，虽然人类理解+0和-0是一样的，但是0带符号是没有任何意义的。
而且会有[0000 0000](原)和[1000 0000](原)两个编码表示0.

于是补码的出现，解决了0的符号以及两个编码的问题：

1-1 
= 1 + (-1)
= [0000 0001](原) + [1000 0001](原) 
= [0000 0001](补) + [1111 1111](补)
= [0000 0000](补)
= [0000 0000](原) //补码转原码，根据上面的值的符号位可知，是一个正数，所以转换为原码时还是自身
= 0

这样0用[0000 0000]表示，而以前出现问题的-0则不存在了。
而且可以用[1000 0000]表示-128.

(-1) + (-127)
= [1000 0001](原) + [1111 1111](原)
= [1111 1111](补) + [1000 0001](补)
= [1000 0000](补)

-1-127的结果应该是-128，在用补码运算的结果中，[1000 0000](补)就是-128.
但是注意因为实际上是使用以前的-0的补码来表示-128，所以-128并没有原码和反码表示。
（对-128的补码表示[1000 0000]补算出来的原码是[0000 0000](原)，这是不正确的）。
使用补码，不仅仅修改了0的符号以及存在两个编码的问题，而且还能够多表示一个最低数。
这就是为什么8位二进制，使用原码或反码表示的范围是[-127, +127]，而使用补码表示的范围为[-128, 127]。
因为机器使用补码，所以对于编程中常用到的32位int类型，可以表示范围是[-2(31次方), 2(31)-1]因为第一位表示的是符号位。
而使用补码表示时又可以多保存一个最小值。


四、原码、反码、补码再深入






Reference
https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html
http://blog.csdn.net/u011080472/article/details/51280919



