一、什么是注解（Annotation）
二、元注解(meta-annotation)
三、自定义Annotation
四、系统内置标准注解
五、总结

一、什么是注解（Annotation）
Annotation（注解）就是Java提供了一种元程序中的元素关联任何信息和着任何元数据（metadata）的途径和方法。Annotion(注解)是一个接口，程序可以通过反射来获取指定程序元素的Annotion对象，然后通过Annotion对象来获取注解里面的元数据。
　　Annotation(注解)是JDK5.0及以后版本引入的。它可以用于创建文档，跟踪代码中的依赖性，甚至执行基本编译时检查。从某些方面看，annotation就像修饰符一样被使用，并应用于包、类 型、构造方法、方法、成员变量、参数、本地变量的声明中。这些信息被存储在Annotation的“name=value”结构对中。
　　Annotation的成员在Annotation类型中以无参数的方法的形式被声明。其方法名和返回值定义了该成员的名字和类型。在此有一个特定的默认语法：允许声明任何Annotation成员的默认值：一个Annotation可以将name=value对作为没有定义默认值的Annotation成员的值，当然也可以使用name=value对来覆盖其它成员默认值。这一点有些近似类的继承特性，父类的构造函数可以作为子类的默认构造函数，但是也可以被子类覆盖。
　　Annotation能被用来为某个程序元素（类、方法、成员变量等）关联任何的信息。需要注意的是，这里存在着一个基本的规则：Annotation不能影响程序代码的执行，无论增加、删除 Annotation，代码都始终如一的执行。另外，尽管一些annotation通过java的反射api方法在运行时被访问，而java语言解释器在工作时忽略了这些annotation。正是由于java虚拟机忽略了Annotation，导致了annotation类型在代码中是“不起作用”的； 只有通过某种配套的工具才会对annotation类型中的信息进行访问和处理。本文中将涵盖标准的Annotation和meta-annotation类型，陪伴这些annotation类型的工具是java编译器（当然要以某种特殊的方式处理它们）。

二、元注解(meta-annotation)
元注解是指注解的注解，只能应用于自定义Annotation上。
Java提供了四种元注解，如下
Target
表示可以修饰的对象，ElementType的取值有：
TYPE //Class, interface (including annotation type), or enum declaration
FIELD //Field declaration (includes enum constants)
METHOD //Method declaration
PARAMETER //Parameter declaration
CONSTRUCTOR //Constructor declaration
LOCAL_VARIABLE //Local variable declaration
ANNOTATION_TYPE //Annotation type declaration
PACKAGE //Package declaration

Retention
表示注解保留策略，RetentionPolicy的取值有：
/**
* Annotations are to be discarded by the compiler.
*/
SOURCE,

/**
 * Annotations are to be recorded in the class file by the compiler
 * but need not be retained by the VM at run time.  This is the default
 * behavior.
 */
CLASS,

/**
 * Annotations are to be recorded in the class file by the compiler and
 * retained by the VM at run time, so they may be read reflectively.
 *
 * @see java.lang.reflect.AnnotatedElement
 */
RUNTIME

Documented
表示此注解通过javadoc tool可被文档分

Inherited
此元注解为标记注解，当被标注在某个注解上时，表示此注解具有继承性。
如果一个使用了@Inherited修饰的Annotation类型被应用于一个Class，则这个Annotation
将被用于该Class的子类。
Note:自定义的Annotation只能标注在类上。

三、自定义Annotation
使用@interface自定义注解时，自动继承了java.lang.annotation.Annotation接口，由编译程序自动完成其他细节。在定义注解时，不能继承其他的注解或接口。@interface用来声明一个注解，其中的每一个方法实际上是声明了一个配置参数。方法的名称就是参数的名称，返回值类型就是参数的类型（返回值类型只能是基本类型、Class、String、enum）。可以通过default来声明参数的默认值。

定义注解格式：
public @interface 注解名 {定义体}

注解参数的可支持数据类型：
//only primitive type, String, Class, annotation, enumeration are permitted or 1-dimensional arrays thereof
1、primitive type（int,float,boolean,byte,double,char,long,short)
2、String
3、Class
4、enum
5、Annotation
6、以上所有类型的数组

Annotation类型里面的参数该怎么设定:
第一 只能用public或不写（default）
第二 见注解参数的可支持数据类型
第三 如果只有一个参数，最好把参数名称设为"value",后面跟小括号

例子：
FruitName.java
/**
 * 水果名称注解
 * @author victor
 */
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface FruitName {
	
	public String value() default "";
	
}

FruitColor.java
/**
 * 水果颜色注解
 * @author victor
 */
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface FruitColor {
	
	/**
	 * 水果颜色枚举
	 * @author victor
	 */
	public enum Color {BLUE, RED, GREEN};
	
	/**
	 * 颜色属性
	 * @return
	 */
	Color fruitColor() default Color.GREEN;;
	
}

Apple.java
public class Apple {
	
	@FruitName("Apple")
	public String appleName;
	
	@FruitColor(fruitColor = Color.BLUE)
	public String appleColor;
	
	/* setter/getter method */
}

注解元素的默认值:
注解元素必须有确定的值，要么在定义注解的默认值中指定，要么在使用注解时指定，非基本类型的注解元素的值不可为null。因此, 使用空字符串或0作为默认值是一种常用的做法。这个约束使得处理器很难表现一个元素的存在或缺失的状态，因为每个注解的声明中，所有元素都存在，并且都具有相应的值，为了绕开这个约束，我们只能定义一些特殊的值，例如空字符串或者负数，一次表示某个元素不存在，在定义注解时，这已经成为一个习惯用法。
例如:
/**
 * 水果供应商
 * @author victor
 */
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface FruitProvider {
	
	/**
	 * 供应商ID
	 * @return
	 */
	public int id() default -1;
	
	/**
	 * 供应商名称
	 * @return
	 */
	public String name() default "";
	
	/**
	 * 供应商地址
	 * @return
	 */
	public String add() default "";
	
}

四、系统内置标准注解
注解的语法比较简单，除了@符号的使用外，他基本与Java固有的语法一致，JavaSE中内置三个标准注解，定义在java.lang中：
@Override: 用于修饰此方法覆盖了父类的方法;
@Deprecated: 用于修饰已经过时的方法;
@SuppressWarnnings: 用于通知java编译器禁止特定的编译警告。

下面我们依次看看三个内置标准注解的作用和使用场景。

@Override，限定重写父类方法
@Override 是一个标记注解类型，它被用作标注方法。它说明了被标注的方法重载了父类的方法，起到了断言的作用。如果我们使用了这种Annotation在一个没有覆盖父类方法的方法时，java编译器将以一个编译错误来警示。这个annotaton常常在我们试图覆盖父类方法而确又写错了方法名时发挥威力。使用方法极其简单：在使用此annotation时只要在被修饰的方法前面加上@Override即可。下面的代码是一个使用@Override修饰一个企图重载父类的paoniu()方法，而又存在拼写错误的实例
Father.java
public class Father {
	public String paoniu() {
		return "Father paoniu";
	}
}

Son.java
public class Son extends Father {
	@Override
	public String paonia() { //The method paonia() of type Son must override or implement a supertype method
		return "Son paonia";
	}
}

被标注为@Override的方法必须是覆盖父类的方法，否则编译错误！

@Deprecated，标记已过时
Deprecated也是一个标记注解。当一个类型或者类型成员使用@Deprecated修饰的话，编译器将不鼓励使用这个被标注的程序元素。而且这种修饰具有一定的“延续性”：如果我们在代码中通过继承或者覆盖的方式使用了这个过时的类型或者成员，虽然继承或者覆盖后的类型或者成员并不是被声明为@Deprecated，但编译器仍然要报警。

值得注意，@Deprecated这个annotation类型和javadoc中的@deprecated这个tag是有区别的：前者是java编译器识别的，而后者是被javadoc工具所识别用来生成文档（包含程序成员为什么已经过时、它应当如何被禁止或者替代的描述）。

在java5.0，java编译器仍然象其从前版本那样寻找@deprecated这个javadoc tag，并使用它们产生警告信息。但是这种状况将在后续版本中改变，我们应在现在就开始使用@Deprecated来修饰过时的方法而不是 @deprecated javadoc tag。

下面一段程序中使用了@Deprecated注解标示方法过期，同时在方法注释中用@deprecated tag 标示该方法已经过时，代码如下：
Father.java
public class Father {
	/**
	 * @deprecated old method is desn't work, 
	 * replaced by <code>Father.kiss()</code>.
	 * @return
	 */
	@Deprecated
	public String paoniu() {
		return "Father paoniu";
	}
	
	public String kiss() {
		return "Father kiss";
	}
}

Son.java
public class Son extends Father {
	
	@Override
	public String paoniu() {
		return "Son paoniu";
	}
	
	public static void main(String[] args) {
		Father son  = new Son();
		System.out.println(son.paoniu()); //提示过期
	}
}
在Son的main方法里调用paoniu()方法时提示过期！

@SuppressWarnings，抑制编译器警告
AppleService.java
public class AppleService {
	@SuppressWarnings(value = { "rawtypes", "unchecked" })
	// @SuppressWarnings({ "rawtypes", "unchecked" })
	public static List<Apple> getAppleList() {
		List<Apple> appList = new ArrayList();
		return appList;
	}
}
在这个例子中SuppressWarnings annotation类型只定义了一个单一的成员，所以只有一个简单的value={...}作为name=value对。又由于成员值是一个数组，故使用大括号来声明数组值。注意：我们可以在下面的情况中缩写annotation：当annotation只有单一成员，并成员命名为"value="。这时可以省去"value="。比如将上面方法getFruit()的SuppressWarnings annotation就是缩写的。

SuppressWarnings注解的常见参数值的简单说明：
1.deprecation：使用了不赞成使用的类或方法时的警告；
2.unchecked：执行了未检查的转换时的警告，例如当使用集合时没有用泛型 (Generics) 来指定集合保存的类型; 
3.fallthrough：当 Switch 程序块直接通往下一种情况而没有 Break 时的警告;
4.path：在类路径、源文件路径等中有不存在的路径时的警告; 
5.serial：当在可序列化的类上缺少 serialVersionUID 定义时的警告; 
6.finally：任何 finally 子句不能正常完成时的警告; 
7.all：关于以上所有情况的警告。

SuppressWarnings注解的常见可参考此文章。
http://blog.csdn.net/mddy2001/article/details/8291484

五、总结
1, 四种meta-annotation
	@Target: 表示修饰的对象范围
	@Retention: 表示注解的保留级别
	@Documented: 可被文档化
	@Inherited: 表示被标注的注解是否有继承特性
2, 自定义Annotation
	a, 使用@interface定义Annotation
	b, 参数修饰符有public, default
	c, 参数仅支持基本类型、String, Class, annotation, enumeration及其数组形式
	d, 参数必须要有默认值
3, 内置注解
	@Override: 表示此方法为覆盖父类中的方法
	@Deprecated: 标记为过期的方法
	@SuppressWarnings: 抑制编译器警告





