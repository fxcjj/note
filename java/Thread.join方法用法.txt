Thread.join方法用法

一、案例1
代码清单1
public class Test implements Runnable {
	
	private static int a;
	
	private synchronized void inc() {
		a++;
	}
	
	public void run() {
		for(int i = 0; i < 5; i++) {
			inc();
		}
	}
	
	public static void main(String[] args) throws Exception {
		Test t = new Test();
		Thread thread = new Thread(t);
		thread.start();
		
		System.out.println(a);
	}

}

output:
0

为什么会是0呢，而不是5？
原因：
start()方法只是让线程进入就绪状态，并没有立刻执行。
此时main线程执行，则打印a的值为0，这里的0也不是绝对的，如果start()方法执行一部分或执行完毕（执行a++），那打印的值为随机值。


二、加入join方法
代码清单2
public class Test implements Runnable {
	
	private static int a;
	
	private synchronized void inc() {
		a++;
	}
	
	public void run() {
		for(int i = 0; i < 5; i++) {
			inc();
		}
	}
	
	public static void main(String[] args) throws Exception {
		Test t = new Test();
		Thread thread = new Thread(t);
		thread.start();
		
		//等待thread线程执行完毕
		thread.join();
		
		System.out.println(a);
	}

}

output:
5

Conclusion
join方法的作用是把指定的线程加入到当前线程，将两个交替执行的线程变成顺序执行的线程。
比如在线程B中调用线程A的join方法，则线程A执行完毕后，才会继续执行线程B。
in other words, 当调用线程实例的start方法后，这个方法会立即返回，继续执行后面的代码。
如果后面的代码有用到start方法的返回值（或影响的变量），则必须使用join方法（以保证顺序执行），如果不使用join方法，则无法保证后续代码正确。


