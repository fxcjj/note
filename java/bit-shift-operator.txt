
1. 位运算符
	1.1 按位与&
	1.2 按位或|
	1.3 按位非~
	1.4 按位异或^
	1.5 左位移运算符<<
	1.6 右位移运算符>>
	1.7 无符号右位移运算符<<<
2. 常见使用
	2.1 m*2^n
	2.2 判断一个数n的奇偶性
	2.3 不用临时变量交换两个数
	2.4 取绝对值
	
	
1.1 按位与&
运算规则
operator1	0	0	1	1
operator2	0	1	0	1
result		0	0	0	1

规则总结：
只有两个操作数对应位同为1时，结果为1，否则为0（或者只要有一个操作数为0，结果为0）

举例1：
	10
& 	12
-----------(D)
	8

转换为二进制运算
	
	1010
&	1100
-----------(B)
	1000


举例2：
	-6
& 	-2
-----------(D)
	-6
	
转换为二进制运算

-6
1000 0000 0000 0000 0000 0000 0000 0110（原）
1111 1111 1111 1111 1111 1111 1111 1001（反）
1111 1111 1111 1111 1111 1111 1111 1010（补）

-2
1000 0000 0000 0000 0000 0000 0000 0010（原）
1111 1111 1111 1111 1111 1111 1111 1101（反）
1111 1111 1111 1111 1111 1111 1111 1110（补）

负数要补码运算
	1111 1111 1111 1111 1111 1111 1111 1010（补）
&	1111 1111 1111 1111 1111 1111 1111 1110（补）
--------------------------------------------------
	1111 1111 1111 1111 1111 1111 1111 1010（补）
转换为反码-1
	1111 1111 1111 1111 1111 1111 1111 1001
转换为原码除符号位外，其余取反
	1000 0000 0000 0000 0000 0000 0000 0110
转换为十进制
	-6


举例3：
	 6
& 	-2
-----------(D)
	6
	
转换为二进制运算

	0000 0000 0000 0000 0000 0000 0000 0110（原/反/补）
&	1111 1111 1111 1111 1111 1111 1111 1110（补）
--------------------------------------------------
	0000 0000 0000 0000 0000 0000 0000 0110
	

1.2 按位或|
运算规则
operator1	0	0	1	1
operator2	0	1	0	1
result		0	1	1	1

规则总结：
只有两个操作数对应位同为0时，结果为0，否则为1（或者只要有一个操作数为1时，结果为1）


1.3 按位非~
operator	0	1
result		1	0

举例1：
-5
1000 0000 0000 0000 0000 0000 0000 0101（原）
1111 1111 1111 1111 1111 1111 1111 1010（反）
1111 1111 1111 1111 1111 1111 1111 1011（补）
按位非一下
0000 0000 0000 0000 0000 0000 0000 0100
此时为正数，转换为十进制
4

举例2：
6
0000 0000 0000 0000 0000 0000 0000 0110（原/反/补）
按位非得到
	1111 1111 1111 1111 1111 1111 1111 1001
计算机以补码形式存储数值，最高位为1，说明是一个负数。
需要将负数转换为原码，即
补码-1得到反码
	1111 1111 1111 1111 1111 1111 1111 1000
除符号位不变其余取反得到原码
	1000 0000 0000 0000 0000 0000 0000 0111
转换为十进制	
-7


处理过程：
a) 将运算数转换为计算机存储的数值（即机器数）
b) 将机器数按位取反（0->1,1->0）
c) 取反后如果为负数，则转换为原码，然后转换为十进制
d) 取反后如果为正数，直接转换为十进制，

简单的理解，对任一数值 x 进行按位非操作的结果为 -(x+1)
那么, ~~x就为 -(-(x+1) + 1)


1.4 按位异或^
运算规则
operator1	0	0	1	1
operator2	0	1	0	1
result		0	1	1	0

规则总结：
当两个操作数对应位相同时，结果为0，否则为1

按位异或的3个特点:
	a) 0^0=0,0^1=1  0异或任何数＝任何数，即异或0具有保持的特点。
	b) 1^0=1,1^1=0  1异或任何数－任何数取反，即异或1具有翻转的特点。
	c) 任何数异或自己＝把自己置0
常见用途:
	a) 使某些特定的位翻转（使用到第b个特点）
    例如: 对数10100001的第2位和第3位翻转，则可以将该数与00000110进行按位异或运算。
	10100001 ^ 00000110 = 10100111

	b) 实现两个值的交换，而不必使用临时变量。
    例如: 交换两个整数a=110，b=101的值，可通过下列语句实现：
		a = a^b; //a=011
		b = b^a; //b=110
		a = a^b; //a=101

//a = a^b		
110
101
----
011

//b = b^a
101
011
-----
110

//a = a^b
011
110
----
101

其实java中的异或运算法则完全遵守数学中的计算法测：
a) a ^ a = 0
b) a ^ b = b ^ a
c) a ^ b ^ c = a ^ (b ^ c) = (a ^ b) ^ c
d) d = a ^ b ^ c 可以推出 a = d ^ b ^ c
e) a ^ b ^ a = b


1.5 左位移运算符<<
高位舍弃，低位补0。 即：n << num，相当n * 2^num

举例1：
5 << 2 = 5 * 2^2 = 20

0000 0000 0000 0000 0000 0000 0000 0101（原）
左移2位
0000 0000 0000 0000 0000 0000 0001 0100
转换为十进制为
20

举例2：
-6 << 3 = -6 * 2^3 = -48
1000 0000 0000 0000 0000 0000 0000 0110（原）
1111 1111 1111 1111 1111 1111 1111 1001（反）
1111 1111 1111 1111 1111 1111 1111 1010（补）
将补码左移3位
1 1111 1111 1111 1111 1111 1111 1010000
1 1111 1111 1111 1111 1111 1111 1001111（-1后）
1 0000 0000 0000 0000 0000 0000 0110000（除符号位外取反）
转换为十进制为
-48

	1010000
-		  1
--------------
	1001111
	
	1001111
+	      1
--------------
	1010000  		


1.6 右位移运算符>>
>>是带符号右移，若左操作数是正数，则高位补0，若左操作数是负数，则高位补1

举例1：
5 >> 2

0000 0000 0000 0000 0000 0000 0000 0101（原）
右移2位
00 0000 0000 0000 0000 0000 0000 0000 01
转换为十进制为
1

举例2：
-6 >> 1
1000 0000 0000 0000 0000 0000 0000 0110（原）
1111 1111 1111 1111 1111 1111 1111 1001（反）
1111 1111 1111 1111 1111 1111 1111 1010（补）
将补码右移1位
1111 1111 1111 1111 1111 1111 1111 1101
1111 1111 1111 1111 1111 1111 1111 1100（反码，即-1后）
1000 0000 0000 0000 0000 0000 0000 0011（原码，即除符号位外取反）
转换为十进制为
-3

举例3：
-6 >> 2
1000 0000 0000 0000 0000 0000 0000 0110（原）
1111 1111 1111 1111 1111 1111 1111 1001（反）
1111 1111 1111 1111 1111 1111 1111 1010（补）
将补码右移1位
11111 1111 1111 1111 1111 1111 111 1110
11111 1111 1111 1111 1111 1111 111 1101（反码，即-1后）
1000 0000 0000 0000 0000 0000 0000 0010（原码，即除符号位外取反）
转换为十进制为
-2

	1110
-	   1
----------
	1101


1.7 无符号右位移运算符>>>
>>> 是无符号右移，无论是正数还是负数，都在高位补0

举例1：
5 >>> 2

0000 0000 0000 0000 0000 0000 0000 0101（原）
右移2位
00 0000 0000 0000 0000 0000 0000 0000 01
转换为十进制为
1

举例2：
-6 >>> 1
1000 0000 0000 0000 0000 0000 0000 0110（原）
1111 1111 1111 1111 1111 1111 1111 1001（反）
1111 1111 1111 1111 1111 1111 1111 1010（补）
无符号右移1位
0111 1111 1111 1111 1111 1111 1111 1101
转换为十进制为
2147483645

举例3：
-6 >>> 2
1000 0000 0000 0000 0000 0000 0000 0110（原）
1111 1111 1111 1111 1111 1111 1111 1001（反）
1111 1111 1111 1111 1111 1111 1111 1010（补）
无符号右移2位
00111 1111 1111 1111 1111 1111 1111 110
转换为十进制为
1073741822

2. 常见使用
2.1 m*2^n
可以使用m << n求得结果，如：
1 << 3
=1 * 2^3
=1 * 8
=8

3 << 3
=3 * 2^3
=3 * 8
=24


计算结果是不是很正确呢？如果非要说2<<-1为什么不等于0.5，前面说过，位运算的操作数只能是整型和char型。
在求int所能表示的最小值时，可以使用

//minInt

System.out.println(1 << 31);

System.out.println(1 << -1);

可以发现左移31位和-1位所得的结果是一样的，同理，左移30位和左移-2所得的结果也是一样的。
移动一个负数位，是不是等同于右移该负数的绝对值位呢？输出一下就能发现不是的。
java中int所能表示的最大数值是31位，加上符号位共32位。
在这里可以有这样的位移法则：
法则一：任何数左移（右移）32的倍数位等于该数本身。
法则二：在位移运算m<<n的计算中，若n为正数，则实际移动的位数为n%32，若n为负数，则实际移动的位数为(32+n%32)，右移，同理。

左移是乘以2的幂，对应着右移则是除以2的幂。

2.2 判断一个数n的奇偶性
n&1 == 1 ? "odd" : "even";
为什么与1能判断奇偶？
所谓的二进制就是满2进1，那么好了，偶数的最低位肯定是0（恰好满2），同理，奇数的最低位肯定是1。
int类型的1，前31位都是0，无论是1&0还是0&0结果都是0，
那么有区别的就是1的最低位上的1了，若n的二进制最低位是1（奇数）与上1，结果为1，反则结果为0.

2.3 不用临时变量交换两个数
//临时变量
int tmp;
int a = 1;
int b = 2;

//swap
tmp = 1;
a = 2;
b = tmp;

//使用异或交换
//a = a^b
0011
0100
---------
0111

int a = 3;
int b = 4;
a = a ^ b; //a异或b得到结果
b = a ^ b; //结果a异或b，得到原来的a
a = a ^ b; //结果a异或现在的b（是原来的a），得到原来的b

System.out.println(a); //4
System.out.println(b); //3

上面的计算主要遵循一个计算公式：b^(a^b)=a
对以上公式做如下推导：
a) 任何数异或本身结果为0且有定理a^b=b^a.
b) 异或是一个无顺序的运算符，则b^a^b=b^b^a，结果为0^a



2.4 取绝对值
(a^(a>>31))-(a>>31)

异或0具有保持的特点。
异或1具有翻转的特点。

任何正数右移31后只剩符号位0，最终结果为0，任何负数右移31后也只剩符号位1，溢出的31位截断，空出的31位补符号位1，
最终结果为-1。右移31可以取得任何整数的符号位。

那么综合上面的步骤，可得到公式。

a>>31取得a的符号，若a为正数，a>>31等于0，a^0=a，不变；
若a为负数,a>>31等于-1，a^-1翻转每一位。

//若a为正数
(a^(a>>31))-(a>>31)
=(a^0)-0
=a-0
=a

//若a为负数
(a^(a>>31))-(a>>31)
=(a^-1)-(-1)
=(a^-1)+1 //-1的补码全是1所以起到翻转的作用


Refference
https://blog.csdn.net/goskalrie/article/details/52796360

Code
/rumor/src/main/java/cn/rumor/old/bitshift/ShiftTest.java



B，Binary（二进制）
H，Hex（十六进制）
O，Octal（八进制）
D，Decimal（十进制）