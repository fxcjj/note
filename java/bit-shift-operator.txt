
1. 位运算符
	1.1 按位与&
	1.2 按位或|
	1.3 按位非~
	1.4 按位异或^
	1.5 左位移运算符<<
	1.6 右位移运算符>>
	1.7 无符号右位移运算符<<<
2. 常见使用
	2.1 m*2^n
	2.2 判断一个数n的奇偶性
	2.3 不用临时变量交换两个数
	2.4 取绝对值
	
	
1.1 按位与&
运算规则
operator1	0	0	1	1
operator2	0	1	0	1
result		0	0	0	1

规则总结：
只有两个操作数对应位同为1时，结果为1，否则为0（或者只要有一个操作数为0，结果为0）

举例1：
	10
& 	12
-----------(D)
	8

转换为二进制运算
	
	1010
&	1100
-----------(B)
	1000


举例2：
	-6
& 	-2
-----------(D)
	-6
	
转换为二进制运算

-6
1000 0000 0000 0000 0000 0000 0000 0110（原）
1111 1111 1111 1111 1111 1111 1111 1001（反）
1111 1111 1111 1111 1111 1111 1111 1010（补）

-2
1000 0000 0000 0000 0000 0000 0000 0010（原）
1111 1111 1111 1111 1111 1111 1111 1101（反）
1111 1111 1111 1111 1111 1111 1111 1110（补）

负数要补码运算
	1111 1111 1111 1111 1111 1111 1111 1010（补）
&	1111 1111 1111 1111 1111 1111 1111 1110（补）
--------------------------------------------------
	1111 1111 1111 1111 1111 1111 1111 1010（补）
转换为反码-1
	1111 1111 1111 1111 1111 1111 1111 1001
转换为原码除符号位外，其余取反
	1000 0000 0000 0000 0000 0000 0000 0110
转换为十进制
	-6


举例3：
	 6
& 	-2
-----------(D)
	6
	
转换为二进制运算

	0000 0000 0000 0000 0000 0000 0000 0110（原/反/补）
&	1111 1111 1111 1111 1111 1111 1111 1110（补）
--------------------------------------------------
	0000 0000 0000 0000 0000 0000 0000 0110
	

1.2 按位或|
运算规则
operator1	0	0	1	1
operator2	0	1	0	1
result		0	1	1	1

规则总结：
只有两个操作数对应位同为0时，结果为0，否则为1（或者只要有一个操作数为1时，结果为1）


1.3 按位非~
operator	0	1
result		1	0

举例1：
-5
1000 0000 0000 0000 0000 0000 0000 0101（原）
1111 1111 1111 1111 1111 1111 1111 1010（反）
1111 1111 1111 1111 1111 1111 1111 1011（补）
按位非一下
0000 0000 0000 0000 0000 0000 0000 0100
此时为正数，转换为十进制
4

举例2：
6
0000 0000 0000 0000 0000 0000 0000 0110（原/反/补）
按位非得到
	1111 1111 1111 1111 1111 1111 1111 1001
计算机以补码形式存储数值，最高位为1，说明是一个负数。
需要将负数转换为原码，即
补码-1得到反码
	1111 1111 1111 1111 1111 1111 1111 1000
除符号位不变其余取反得到原码
	1000 0000 0000 0000 0000 0000 0000 0111
转换为十进制	
-7


处理过程：
a) 将运算数转换为计算机存储的数值（即机器数）
b) 将机器数按位取反（0->1,1->0）
c) 取反后如果为负数，则转换为原码，然后转换为十进制
d) 取反后如果为正数，直接转换为十进制，

简单的理解，对任一数值 x 进行按位非操作的结果为 -(x+1)
那么, ~~x就为 -(-(x+1) + 1)


1.4 按位异或^
运算规则
operator1	0	0	1	1
operator2	0	1	0	1
result		0	1	1	0

规则总结：
当两个操作数对应位相同时，结果为0，否则为1

按位异或的3个特点:
	a) 0^0=0,0^1=1  0异或任何数＝任何数
	b) 1^0=1,1^1=0  1异或任何数－任何数取反
	c) 任何数异或自己＝把自己置0
常见用途:
	a) 使某些特定的位翻转（使用到第b个特点）
    例如: 对数10100001的第2位和第3位翻转，则可以将该数与00000110进行按位异或运算。
	10100001 ^ 00000110 = 10100111

	b) 实现两个值的交换，而不必使用临时变量。
    例如: 交换两个整数a=110，b=101的值，可通过下列语句实现：
		a = a^b; //a=011
		b = b^a; //b=110
		a = a^b; //a=101

110
101
----
011

101
011
-----
110

011
110
----
101


1.5 左位移运算符<<
高位舍弃，低位补0。 即：n << num，相当n * 2^num

举例1：
5 << 2 = 5 * 2^2 = 20

0000 0000 0000 0000 0000 0000 0000 0101（原）
左移2位
0000 0000 0000 0000 0000 0000 0001 0100
转换为十进制为
20

举例2：
-6 << 3 = -6 * 2^3 = -48
1000 0000 0000 0000 0000 0000 0000 0110（原）
1111 1111 1111 1111 1111 1111 1111 1001（反）
1111 1111 1111 1111 1111 1111 1111 1010（补）
将补码左移3位
1 1111 1111 1111 1111 1111 1111 1010000
1 1111 1111 1111 1111 1111 1111 1001111（-1后）
1 0000 0000 0000 0000 0000 0000 0110000（除符号位外取反）
转换为十进制为
-48

	1010000
-		  1
--------------
	1001111
	
	1001111
+	      1
--------------
	1010000  		


1.6 右位移运算符>>
>>是带符号右移，若左操作数是正数，则高位补0，若左操作数是负数，则高位补1

举例1：
5 >> 2

0000 0000 0000 0000 0000 0000 0000 0101（原）
右移2位
00 0000 0000 0000 0000 0000 0000 0000 01
转换为十进制为
1

举例2：
-6 >> 1
1000 0000 0000 0000 0000 0000 0000 0110（原）
1111 1111 1111 1111 1111 1111 1111 1001（反）
1111 1111 1111 1111 1111 1111 1111 1010（补）
将补码右移1位
1111 1111 1111 1111 1111 1111 1111 1101
1111 1111 1111 1111 1111 1111 1111 1100（-1后）
1000 0000 0000 0000 0000 0000 0000 0011（除符号位外取反）
转换为十进制为
-3

举例3：
-6 >> 2
1000 0000 0000 0000 0000 0000 0000 0110（原）
1111 1111 1111 1111 1111 1111 1111 1001（反）
1111 1111 1111 1111 1111 1111 1111 1010（补）
将补码右移1位
11111 1111 1111 1111 1111 1111 111 1110
11111 1111 1111 1111 1111 1111 111 1101（-1后）
1000 0000 0000 0000 0000 0000 0000 0010（除符号位外取反）
转换为十进制为
-2

	1110
-	   1
----------
	1101


1.7 无符号右位移运算符>>>
>>> 是无符号右移，无论是正数还是负数，都在高位补0

举例1：
5 >>> 2

0000 0000 0000 0000 0000 0000 0000 0101（原）
右移2位
00 0000 0000 0000 0000 0000 0000 0000 01
转换为十进制为
1

举例2：
-6 >>> 1
1000 0000 0000 0000 0000 0000 0000 0110（原）
1111 1111 1111 1111 1111 1111 1111 1001（反）
1111 1111 1111 1111 1111 1111 1111 1010（补）
无符号右移1位
0111 1111 1111 1111 1111 1111 1111 1101
转换为十进制为
2147483645

举例3：
-6 >>> 2
1000 0000 0000 0000 0000 0000 0000 0110（原）
1111 1111 1111 1111 1111 1111 1111 1001（反）
1111 1111 1111 1111 1111 1111 1111 1010（补）
无符号右移1位
00111 1111 1111 1111 1111 1111 1111 110
转换为十进制为
1073741822

2. 常见使用
2.1 m*2^n
可以使用m << n求得结果，如：
1 << 3
=1 * 2^3
=1 * 8
=8

3 << 3
=3 * 2^3
=3 * 8
=24


计算结果是不是很正确呢？如果非要说2<<-1为什么不等于0.5，前面说过，位运算的操作数只能是整型和字符型。
在求int所能表示的最小值时，可以使用

//minInt

System.out.println(1 << 31);

System.out.println(1 << -1);

可以发现左移31位和-1位所得的结果是一样的，同理，左移30位和左移-2所得的结果也是一样的。移动一个负数位，是不是等同于右移该负数的绝对值位呢？输出一下就能发现不是的。java中int所能表示的最大数值是31位，加上符号位共32位。在这里可以有这样的位移法则：

法则一：任何数左移（右移）32的倍数位等于该数本身。

法则二：在位移运算m<<n的计算中，若n为正数，则实际移动的位数为n%32，若n为负数，则实际移动的位数为(32+n%32)，右移，同理。

左移是乘以2的幂，对应着右移则是除以2的幂。

2.2 判断一个数n的奇偶性
2.3 不用临时变量交换两个数
2.4 取绝对值




Refference
https://blog.csdn.net/goskalrie/article/details/52796360


B，Binary（二进制）；
H，Hex（十六进制）；
O，Octal（八进制）；
D，Decimal（十进制）。