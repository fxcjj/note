创建高性能的索引

5.1 索引基础
先在索引中找到对应值，然后根据匹配的索引记录找到对应的数据行。
列的顺序十分重要，mysql只能高效地使用索引的最左前缀列

5.1.1 索引的类型
存储引擎层实现
没有统一的索引标准

B-Tree索引
哈希索引
空间数据索引
全文索引
其他索引类别

5.2 索引的优点
1. 索引大大减少了服务器需要扫描的数据量
2. 索引可以帮助服务器避免排序和临时表
3. 索引可以将随机I/O变为顺序I/O

5.3 高性能的索引策略
正确地创建和使用索引是实现高性能查询的基础

5.3.1 独立的列
不能是表达式的一部分，也不能是函数的参数

5.3.2 前缀索引和索引选择性
索引的选择性是指，不重复的索引值（也称为基数 cardinality）和
数据表的记录总数（#T）的比值，范围从1/#T到1之间。

唯一索引的选择性是1，这是最好索引选择性，性能也是最好的。

BLOB、TEXT或很长的VARCHAR类型的列，必须使用前缀索引，
因为mysql不允许索引这些列的完整长度。

诀窍在于选择足够长的前缀以保证较高的选择性，同时又不能太长（以便节约空间）。

另一个办法就是计算完整列的选择性，并使前缀的选择性接近于完整列的选择性。

select count(distinct city)/count(*) from city_demo;

创建前缀索引
alter table city_demo add key(city(7));
缺点：mysql无法使用前缀索引做order by和group by，也无法使用前缀索引做覆盖扫描。


5.3.3 多列索引
一个常见的错误就是，为每个列创建独立的索引，
或者按错误的顺序创建多列索引。

索引合并

三个变种
or条件的联合
and条件的相交
组合前两种情况的联合及相交。

索引合并策略有时候是一种优化的结果，但实际上更多时候说明了表上的索引
建得很糟糕：
	* 多个索引做相交操作时（通常有多个and条件）
	* 多个索引做联合操作时（通常有多个or条件）
	* 优化器不会把这些计算到“查询成本（cost）”中

optimizer_switch关闭索引合并功能


5.3.4 选择合适的索引列顺序

正确的顺序依赖于使用该索引的查询，
并且同时需要考虑如何更好地满足排序和分组的需要。

三星索引

经验法则：将选择性高的列放到索引最前列。
这个建议有用吗？有些场景可能有帮助，

不考虑排序和分组时，将选择性最高的列放在前面通常是很好的。
这时候索引的作用只是用于优化where条件的查找。

异常用户，如管理员

一个用户分享购买商品和购买经验的论坛上

尽管关于选择性和基数的经验法则值得去研究和分析，
但一定要记住别忘了where子句中的排序、分组和范围条件等其他因素，
这些因素可能对查询的性能造成非常大的影响。


5.3.5 聚簇索引













