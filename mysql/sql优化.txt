
1、不要在列上运算
比如：
select * from users where year(add_date) < 2007;
将在每个行进行运算，会导致索引失效进行全表扫描，因为我们可以改成：
select * from users where add_date < '2007-01-01'

2、使用批量插入或批量更新节省交互

3、避免类型转换
这里所说的“类型转换”是指where子句中出现column字段的类型和传入的参数类型不一致的时候发生
的类型转换。人为的通过转换函数进行转换，直接导致mysql无法使用索引。
如果非要转型，应该在传入参数上进行转换。

4、尽量用union all代替union
union和union all的差异主要是前者需要将两个（或多个）结果集合并后再进行唯一性过滤操作，这就会涉及到排序，
增加大量的cpu运算，加大资源消耗及延迟。
所以当我们可以确定不可能出现重复结果集或者不在乎重复结果集的时候，尽量使用union all而不是union。

5、sql语句尽量都大写字母出现

6、数据库处理from后面的语句时，是右侧往左侧处理的，
那么选择数据量最小的表作为基表（from最后面的表），可加快查询速度。
假设有三张表，中间的那个是关联表，作为基表。
例如：
A表，1万条数据
B表，10万条数据
C表，100万条数据
关联条件：A.id = B.id and C.sid = B.sid，此时B就是关联表
查询时：
select * from C, A, B where A.id = B.id and C.sid = B.sid，此时B作为基表出现

7、where后面的条件顺序：连接条件放前面，而其他的条件放后面，由于sql从右侧往左侧执行，此时可以过滤掉大部分数据，
   减少不必要的连接次数。

   


3.limit千万级分页的时候优化。

A．在我们平时用limit,如：

Select * from A order by id limit 1,10;

这样在表数据很少的时候，看不出什么性能问题，倘若到达千万级，如：

Select * from A order by id limit 10000000,10;

虽然都是只查询10记录，但是这个就性能就让人受不了了。所以为什么当表数据很大的时候，我们还继续用持久层框架如hibernate,ibatis就会有一些性能问题，除非持久层框架对这些大数据表做过优化。

B．在遇见上面的情况，我们可以用另外一种语句优化，如：

Select * from A where id>=(Select id from a limit 10000000,1) limit 10;

确实这样快了很多，不过前提是，id字段建立了索引。也许这个还不是最优的，其实还可以这样写：

Select * from A where id between 10000000 and 10000010;