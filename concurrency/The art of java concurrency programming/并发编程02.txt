第2章　Java并发机制的底层实现原理

2.1 volatile的应用
	2.1.1 volatile的定义与实现原理
	2.1.2 volatile的使用优化
2.2 synchronized的实现原理与应用
	2.2.1 Java对象头
	2.2.2 锁的升级与对比
	2.2.3 锁的优缺点对比
2.3 原子操作的实现原理
	2.3.1 术语定义
	2.3.2 处理器如何实现原子操作
	2.3.3 Java如何实现原子操作
2.4 本章小结


Java代码在编译后会变成Java字节码，字节码被类加载器加载到JVM里，JVM执行字节码，
最终需要转化为汇编指令在CPU上执行，Java中所使用的并发机制依赖于JVM的实现和CPU的指令。
本章我们将深入底层一起探索下Java并发机制的底层实现原理。

2.1 volatile的应用
a) volatile是轻量级的synchronized
b) 它在多处理器开发中保证了共享变量的“可见性”。可见性的意思是当一个线程
修改一个共享变量时，另外一个线程能读到这个修改的值。
c) 比synchronized的使用和执行成本更低，因为它不会引起线程上下文的切换和调度

2.1.1 volatile的定义与实现原理
a) cpu术语
	内存屏障
	缓冲行
	原子操作
	缓存行填充
	缓存命中
	写命中
	写缺失
b) 有volatile变量修饰的共享变量进行写操作的时候会多出第二行汇编代码，通过查IA-32架
构软件开发者手册可知，Lock前缀的指令在多核处理器下会引发了两件事情。
	1) 将当前处理器缓存行的数据写回到系统内存。
	2) 这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效。

2.1.2 volatile的使用优化
a) LinkedTransferQueue
b) 使用追加到64字节的方式来填满高速缓冲区的缓存行，避免头节点和尾节点加载到同一个缓存
行，使头、尾节点在修改时不会互相锁定。
c) 两种场景下不应该使用这种方式
	1) 缓存行非64字节宽的处理器
	2) 共享变量不会被频繁地写


2.2 synchronized的实现原理与应用
a) 重量级锁
b) 引入偏向锁和轻量级锁
c) Java中的每一个对象都可以作为锁。具体表现为以下3种形式。
	1) 对于普通同步方法，锁是当前实例对象。
	2) 对于静态同步方法，锁是当前类的Class对象。
	3) 对于同步方法块，锁是Synchonized括号里配置的对象
d) 代码块同步是使用monitorenter和monitorexit指令实现的，而方法同步是使用另外一种方式实现的，
细节在JVM规范里并没有详细说明。但是，方法的同步同样可以使用这两个指令来实现。

2.2.1 Java对象头
	参考E:\note\concurrency\java的对象头和对象组成.txt


2.2.2 锁的升级与对比
	参考E:\note\concurrency\java的对象头和对象组成.txt
	
2.2.3 锁的优缺点对比
偏向锁
轻量级锁
重量级锁
	

2.3 原子操作的实现原理
原子（atomic）本意是“不能被进一步分割的最小粒子”，而原子操作（atomic operation）意
为“不可被中断的一个或一系列操作”。在多处理器上实现原子操作就变得有点复杂。让我们
一起来聊一聊在Intel处理器和Java里是如何实现原子操作的。

2.3.1 术语定义
缓存行			Cache line
比较并交换		Compare and swap
CPU流水线		CPU pipeline
内存顺序冲突	Memory order violation

2.3.2 处理器如何实现原子操作
a) 32位IA-32处理器使用基于对缓存加锁或总线加锁的方式来实现多处理器之间的原子操作
b) 处理器提供总线锁定和缓存锁定两个机制来保证复杂内存操作的原子性
	1) 使用总线锁保证原子性
		i++包含读改写操作
	2) 使用缓存锁保证原子性
		目前处理器采用
		两种情况下处理器不会使用缓存锁定
		第一种情况是：当操作的数据不能被缓存在处理器内部，或操作的数据跨多个缓存行（cache line）时，
		则处理器会调用总线锁定。
		第二种情况是：有些处理器不支持缓存锁定。对于Intel 486和Pentium处理器，
		就算锁定的内存区域在处理器的缓存行中也会调用总线锁定。
针对以上两个机制，我们通过Intel处理器提供了很多Lock前缀的指令来实现。例如，位测
试和修改指令：BTS、BTR、BTC；交换指令XADD、CMPXCHG，以及其他一些操作数和逻辑指
令（如ADD、OR）等，被这些指令操作的内存区域就会加锁，导致其他处理器不能同时访问它。

2.3.3 Java如何实现原子操作
a) 使用循环CAS实现原子操作
	参考E:\note\concurrency\java中cas操作.txt
	参考/cn/rumor/old/concurrency/artofconcurrency/c2/CasTest.java
b) CAS实现原子操作的三大问题
	1) ABA问题,使用AtomicStampedReference
	2) 循环时间长开销大。pause指令
	3) 只能保证一个共享变量的原子操作,使用AtomicReference
c) 使用锁机制实现原子操作
	偏向锁、轻量级锁和互斥锁

2.4 本章小结
volatile、synchronized和原子操作的实现原理。
Java中的大部分容器和框架都依赖于本章介绍的volatile和原子操作的实现原理


References
http://www.cnblogs.com/dolphin0520/p/3920373.html
